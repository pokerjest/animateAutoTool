package api

import (
	"encoding/json"
	"fmt"
	"net/http"
	"path/filepath"
	"sort"
	"strings"
	"time"

	"github.com/gin-gonic/gin"
	"github.com/pokerjest/animateAutoTool/internal/alist"
	"github.com/pokerjest/animateAutoTool/internal/db"
	"github.com/pokerjest/animateAutoTool/internal/model"
	"github.com/pokerjest/animateAutoTool/internal/parser"
)

// GetMikanEpisodesHandler fetches episodes from Mikan RSS for a specific anime/subgroup
func GetMikanEpisodesHandler(c *gin.Context) {
	bangumiID := c.Query("bangumiId")
	subgroupID := c.Query("subgroupId") // Optional

	if bangumiID == "" {
		c.JSON(http.StatusBadRequest, gin.H{"error": "Missing bangumiId"})
		return
	}

	// Track the ID actually used (could be updated by search)
	activeMikanID := bangumiID

	// Construct RSS URL
	// https://mikanani.me/RSS/Bangumi?bangumiId=3141&subgroupid=12
	rssURL := fmt.Sprintf("https://mikanani.me/RSS/Bangumi?bangumiId=%s", bangumiID)
	if subgroupID != "" {
		rssURL += fmt.Sprintf("&subgroupid=%s", subgroupID)
	}

	p := parser.NewMikanParser()

	// Apply Proxy if configured
	var proxyConfig model.GlobalConfig
	if err := db.DB.Where("key = ?", model.ConfigKeyProxyURL).First(&proxyConfig).Error; err == nil {
		p.SetProxy(proxyConfig.Value)
	}
	episodes, err := p.Parse(rssURL)
	if err != nil {
		c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to fetch RSS: " + err.Error()})
		return
	}

	// Limit to recent 20 items to avoid overwhelming the UI
	if len(episodes) > 20 {
		episodes = episodes[:20]
	}

	if len(episodes) == 0 {
		// Fallback: Try searching by Title
		title := c.Query("title")
		if title != "" {
			fmt.Printf("GetMikanEpisodesHandler: Bangumi ID %s yielded no results. Searching for title: %s\n", bangumiID, title)
			searchResults, err := p.Search(title)
			if err == nil && len(searchResults) > 0 {
				newID := searchResults[0].MikanID
				activeMikanID = newID // Update active ID
				fmt.Printf("GetMikanEpisodesHandler: Found Mikan ID %s for title %s. Retrying...\n", newID, title)

				// Retry RSS with new ID
				newRSSURL := fmt.Sprintf("https://mikanani.me/RSS/Bangumi?bangumiId=%s", newID)
				if subgroupID != "" {
					newRSSURL += fmt.Sprintf("&subgroupid=%s", subgroupID)
				}
				episodes, _ = p.Parse(newRSSURL)
			}
		}
	}

	if episodes == nil {
		episodes = []parser.Episode{}
	}

	// Return object with ID and Episodes
	c.JSON(http.StatusOK, gin.H{
		"episodes": episodes,
		"mikanId":  activeMikanID,
	})
}

type PlayRequest struct {
	Magnet   string `json:"magnet"`
	FileName string `json:"fileName"` // Optional, for better folder organization
}

// PlayMagnetHandler adds a magnet task to offline download and returns a playback URL
func PlayMagnetHandler(c *gin.Context) {
	var req PlayRequest
	if err := c.ShouldBindJSON(&req); err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"error": "Invalid request"})
		return
	}

	if req.Magnet == "" {
		c.JSON(http.StatusBadRequest, gin.H{"error": "Magnet link is required"})
		return
	}

	// 1. Add Offline Task to PikPak via AList
	// We use the "PikPak" storage mounted at /PikPak
	// We place instant plays in a specific folder: /PikPak/InstantPlay
	targetPath := "/PikPak/InstantPlay"

	// Ensure target directory exists (this might be tricky with AList API, but typically AddOfflineTask handles path creation or puts in root if not exist)
	// For simplicity, we just try to add the task.

	// Use internal AList wrapper to add task
	// alist.AddOfflineTask(magnet, targetPath) - We might need to implement this wrapper if not exists
	// Currently we only have alist.AddPikPakStorage. Let's assume we can use the driver or generic alist API.

	// Since we don't have a direct helper yet, we might need to invoke the AList internals directly or add a helper.
	// For now, let's look at how we can add an offline task.
	// We'll create a helper in `internal/alist/service.go` called `AddOfflineDownload`

	err := alist.AddOfflineDownload(req.Magnet, targetPath)
	if err != nil {
		// Verify if error is "task already exists" - if so, we can proceed
		if !strings.Contains(err.Error(), "already exists") && !strings.Contains(err.Error(), "duplicate") {
			c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to add offline task: " + err.Error()})
			return
		}
	}

	// 2. Poll for file availability (Instant Play Optimization)
	// If the file is already cached by PikPak, it appears almost instantly.
	// We try to list the directory and find the file matching the magnet content.
	// This is complex because we don't know the exact filename generated by the magnet.

	// SIMPLIFICATION:
	// For V1, we just return success and tell the frontend to redirect to AList file browser or start playing if we can guess the path.
	// Since we can't easily guess the filename from just a magnet hash without querying PikPak task status...
	// We will try to rely on the provided `FileName` if available, or just open the folder.

	// If FileName is provided (parsed from RSS title), we can try to construct the path.
	// However, RSS title != Filename usually (different brackets etc).

	// Better Approach: Return the folder URL so user can click the file.
	// Or, query the offline download tasks list to get the file name.

	// Redirect to internal player instead of AList
	playURL := fmt.Sprintf("/player?path=%s", targetPath)
	c.JSON(http.StatusOK, gin.H{
		"message":      "Task added",
		"folderUrl":    targetPath,
		"alistViewUrl": playURL,
	})
}

type FileNode struct {
	Name     string    `json:"name"`
	Path     string    `json:"path"`
	Size     string    `json:"size"`
	Type     int       `json:"type"` // 1: folder, other: file? Need to check AList model
	Modified time.Time `json:"modified"`
	IsVideo  bool      `json:"is_video"`
	Thumb    string    `json:"thumb"`
}

// GetPlayerHandler serves the player page or file list
func GetPlayerHandler(c *gin.Context) {
	pathParam := c.Query("path")
	if pathParam == "" {
		pathParam = "/PikPak/InstantPlay"
	}

	// Determine if it's a file or folder
	// We can try ListFiles first. If it returns error or empty and path looks like file...
	// Actually AList's ListFiles works on directory.

	// If path ends with video extension, treat as file
	isVideo := false
	exts := []string{".mp4", ".mkv", ".webm", ".avi", ".mov"}
	for _, ext := range exts {
		if strings.HasSuffix(strings.ToLower(pathParam), ext) {
			isVideo = true
			break
		}
	}

	if isVideo {
		// Get Sign URL
		signUrl, err := alist.GetSignUrl(pathParam)
		if err != nil {
			c.HTML(http.StatusInternalServerError, "player.html", gin.H{"Error": "Failed to get video link: " + err.Error()})
			return
		}

		c.HTML(http.StatusOK, "player.html", gin.H{
			"IsPlayer": true,
			"Name":     filepath.Base(pathParam),
			"Path":     pathParam,
			"VideoUrl": signUrl,
			"Parent":   filepath.Dir(pathParam),
		})
		return
	}

	// List Files
	objs, err := alist.ListFiles(pathParam)
	if err != nil {
		c.HTML(http.StatusInternalServerError, "player.html", gin.H{"Error": "Failed to list files: " + err.Error()})
		return
	}

	// Model conversion
	// Using reflection or type assertion since we returned []interface{}
	// AList model.Obj struct: Name, Size, IsDir, Modified...
	// Since we can't import model easily, we'll try to use JSON marshalling round-trip or reflection?
	// Reflection is safer if we don't import model.
	// But `alist` package (our local one) imports `cmd` which imports `model`.
	// We can define a simplified struct here and hope `interface{}` is compatible? No.
	// We should probably rely on JSON serialization in `service.go` if we wanted strict decoupling.
	// But let's try just passing the raw objects to template and access fields by name?
	// Go templates can access struct fields by name even if interface{}.
	// We just need to know the field names.
	// AList model.Obj: Name, Size (int64), IsDir (bool), Modified (time.Time).

	var nodes []FileNode

	// Marshaling to JSON and back is the easiest way to bridge types without importing
	jsonData, _ := json.Marshal(objs)
	_ = json.Unmarshal(jsonData, &nodes) // This won't work matching IsDir field if name differs.
	// AList `Obj` json tags: `json:"name"`, `json:"size"`, `json:"is_dir"`, `json:"modified"`.
	// Let's create a struct matching those tags.
	type AListObj struct {
		Name     string    `json:"name"`
		Size     int64     `json:"size"`
		IsDir    bool      `json:"is_dir"`
		Modified time.Time `json:"modified"`
		Thumb    string    `json:"thumb"`
	}
	var alistObjs []AListObj
	if err := json.Unmarshal(jsonData, &alistObjs); err != nil {
		c.HTML(http.StatusInternalServerError, "player.html", gin.H{"Error": "Failed to parse file list"})
		return
	}

	for _, obj := range alistObjs {
		node := FileNode{
			Name:     obj.Name,
			Path:     filepath.Join(pathParam, obj.Name),
			Size:     formatSize(obj.Size),
			Modified: obj.Modified,
			Thumb:    obj.Thumb,
		}
		if obj.IsDir {
			node.Type = 1
		} else {
			// Check if video
			for _, ext := range exts {
				if strings.HasSuffix(strings.ToLower(obj.Name), ext) {
					node.IsVideo = true
					break
				}
			}
		}
		nodes = append(nodes, node)
	}

	// Sort by Modified Desc
	sort.Slice(nodes, func(i, j int) bool {
		return nodes[i].Modified.After(nodes[j].Modified)
	})

	c.HTML(http.StatusOK, "player.html", gin.H{
		"IsPlayer": false,
		"Path":     pathParam,
		"Files":    nodes,
		"Parent":   filepath.Dir(pathParam),
	})
}

func formatSize(size int64) string {
	gb := float64(size) / 1024 / 1024 / 1024
	if gb > 1 {
		return fmt.Sprintf("%.2f GB", gb)
	}
	mb := float64(size) / 1024 / 1024
	return fmt.Sprintf("%.2f MB", mb)
}
